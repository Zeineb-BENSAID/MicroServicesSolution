# Dockerizing ProductService.API (.NET 8) with SQL Server

This guide explains how to containerize a .NET 8 `ProductService.API` using Docker and Docker Compose.
It includes:

* Multi-stage Dockerfile
* SQL Server container
* EF Core one-shot migration runner
* Production-ready docker-compose setup

---

## What is Docker?

Docker is a platform that packages an application and all its dependencies into a **container**.
A container is a lightweight, isolated environment that ensures the application runs the same everywhere — on your machine, a server, or the cloud.

Key points:

* Bundles your app + dependencies
* Eliminates “works on my machine” issues
* Fast, portable, and consistent

---

## What is Docker Compose?

Docker Compose is a tool for running **multiple containers together** using one YAML file (`docker-compose.yml`).
It’s ideal for applications that consist of several services — such as an API, a database, and background jobs.

Key points:

* Starts multiple containers with one command
* Defines how containers connect to each other
* Useful for microservices and local development

---

## Schema: Docker vs Docker Compose

```
                 ┌────────────────────┐
                 │      DOCKER        │
                 │  Runs ONE container│
                 └───────┬────────────┘
                         │
                         ▼
                 ┌────────────────────┐
                 │  Single Container  │
                 │  (e.g., API only)  │
                 └────────────────────┘


                 ┌────────────────────┐
                 │   DOCKER COMPOSE   │
                 │ Runs MULTIPLE apps │
                 │ as connected units │
                 └─────────┬──────────┘
                           │
                           ▼
      ┌─────────────────────────────────────────────────┐
      │                 docker-compose.yml               │
      │-------------------------------------------------│
      │  - API Container                                 │
      │  - Database Container                            │
      │  - Migration Container                           │
      │  - Other Services                                │
      └─────────────────────────────────────────────────┘
                            │
              ┌─────────────┼─────────────┐
              ▼             ▼             ▼
      ┌────────────┐ ┌────────────┐ ┌────────────┐
      │   API       │ │  SQLServer │ │  Migrate   │
      │  Container  │ │ Container  │ │ Container  │
      └────────────┘ └────────────┘ └────────────┘
```

---
---

## 1. Folder Structure

```
MicroServicesSolution/
├── ProductService.API/
│   ├── ProductService.API.csproj
│   ├── Program.cs
│   ├── appsettings.json
│   └── Dockerfile
├── ProductService.Infrastructure/
│   └── ProductService.Infrastructure.csproj
├── ProductService.Application/
│   └── ProductService.Application.csproj
├── ProductService.Domain/
│   └── ProductService.Domain.csproj
├── docker-compose.yml
└── README.md
```

Key files:

* `ProductService.API/Dockerfile`
* `docker-compose.yml`

---

## 2. Dockerfile for ProductService.API

Create: `ProductService.API/Dockerfile`

```dockerfile
# Stage 1: Base runtime
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
WORKDIR /app
EXPOSE 80
ENV ASPNETCORE_URLS=http://+:80

# Stage 2: Build
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY . .
RUN dotnet restore "ProductService.API/ProductService.API.csproj"
RUN dotnet publish "ProductService.API/ProductService.API.csproj" -c Release -o /app/publish

# Stage 3: Final runtime image
FROM base AS final
WORKDIR /app
COPY --from=build /app/publish .
ENTRYPOINT ["dotnet", "ProductService.API.dll"]
```

Explanation:

* Multi-stage build reduces final image size
* Build stage restores dependencies and publishes the app
* Final stage contains only the runtime and published output

---

## 3. Docker Compose

Create `docker-compose.yml` in the root directory:

```yaml
version: "3.8"

services:
  sqlserver:
    image: mcr.microsoft.com/mssql/server:2019-latest
    environment:
      SA_PASSWORD: "Your_password123"
      ACCEPT_EULA: "Y"
    ports:
      - "1433:1433"
    healthcheck:
      test: ["CMD-SHELL", "/opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P $SA_PASSWORD -Q \"SELECT 1\""]
      interval: 10s
      timeout: 5s
      retries: 10
    volumes:
      - mssqldata:/var/opt/mssql

  productsapi:
    build:
      context: .
      dockerfile: ProductService.API/Dockerfile
    depends_on:
      sqlserver:
        condition: service_healthy
    environment:
      - ConnectionStrings__DefaultConnection=Server=sqlserver,1433;Database=ProductDbTraining;User Id=sa;Password=Your_password123;TrustServerCertificate=True;
      - ASPNETCORE_ENVIRONMENT=Development
      - ASPNETCORE_URLS=http://+:80
    ports:
      - "5000:80"
    restart: unless-stopped

  migrate:
    image: mcr.microsoft.com/dotnet/sdk:8.0
    depends_on:
      - sqlserver
    volumes:
      - ./:/src:cached
    working_dir: /src
    entrypoint: ["sh", "-c"]
    command: >
      "dotnet tool restore &&
       dotnet restore ProductService.API/ProductService.API.csproj &&
       dotnet ef database update --project ProductService.Infrastructure/ProductService.Infrastructure.csproj --startup-project ProductService.API/ProductService.API.csproj --no-build"
    environment:
      - ConnectionStrings__DefaultConnection=Server=sqlserver,1433;Database=ProductDbTraining;User Id=sa;Password=Your_password123;TrustServerCertificate=True;

volumes:
  mssqldata:
```

Explanation:

* SQL Server container with persistent storage
* API waits for SQL Server healthcheck before starting
* Migrate container runs EF Core migrations one-time

---

## 4. Commands

### 4.1 Build and start all services

```bash
docker compose up -d --build
```

Example output:

```
Building productsapi ...
Starting sqlserver ... done
Starting productsapi ... done
```

---

### 4.2 Run EF Core migrations manually

```bash
docker compose run --rm migrate
```

Expected output:

```
Build succeeded.
Applying migration 'InitialCreate'
Done.
```

---

### 4.3 Stop and remove all containers and volumes

```bash
docker compose down -v
```

`-v` removes volumes (database reset).

---

## 5. Notes

* `ConnectionStrings__DefaultConnection` overrides `appsettings.json`
* Replace `SA_PASSWORD` for production (use secrets)
* Run migrations from CI/CD pipeline for production systems
* API exposed on port **5000**
* SQL Server exposed on port **1433**

---

## 6. Summary

* `Dockerfile` → multi-stage .NET 8 build
* `docker-compose.yml` → SQL Server, API, migrations
* Commands → build, run migrations, clean
* Database and API fully containerized and ready for duplication across microservices

---
v 2

---


## 2. Dockerfile for ProductService.API

Create: `ProductService.API/Dockerfile`

```dockerfile
# Stage 1: Base runtime
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
WORKDIR /app
EXPOSE 80
ENV ASPNETCORE_URLS=http://+:80

# Stage 2: Build
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY . .
RUN dotnet restore "ProductService.API/ProductService.API.csproj"
RUN dotnet publish "ProductService.API/ProductService.API.csproj" -c Release -o /app/publish

# Stage 3: Final runtime image
FROM base AS final
WORKDIR /app
COPY --from=build /app/publish .
ENTRYPOINT ["dotnet", "ProductService.API.dll"]
```

Explanation:

* Multi-stage build reduces final image size
* Build stage restores dependencies and publishes the app
* Final stage contains only the runtime and published output

---

## 3. Docker Compose

Create `docker-compose.yml` in the root directory:

```yaml
version: "3.8"

services:
  sqlserver:
    image: mcr.microsoft.com/mssql/server:2019-latest
    environment:
      SA_PASSWORD: "Your_password123"
      ACCEPT_EULA: "Y"
    ports:
      - "1433:1433"
    healthcheck:
      test: ["CMD-SHELL", "/opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P $SA_PASSWORD -Q \"SELECT 1\""]
      interval: 10s
      timeout: 5s
      retries: 10
    volumes:
      - mssqldata:/var/opt/mssql

  productsapi:
    build:
      context: .
      dockerfile: ProductService.API/Dockerfile
    depends_on:
      sqlserver:
        condition: service_healthy
    environment:
      - ConnectionStrings__DefaultConnection=Server=sqlserver,1433;Database=ProductDbTraining;User Id=sa;Password=Your_password123;TrustServerCertificate=True;
      - ASPNETCORE_ENVIRONMENT=Development
      - ASPNETCORE_URLS=http://+:80
    ports:
      - "5000:80"
    restart: unless-stopped

  migrate:
    image: mcr.microsoft.com/dotnet/sdk:8.0
    depends_on:
      - sqlserver
    volumes:
      - ./:/src:cached
    working_dir: /src
    entrypoint: ["sh", "-c"]
    command: >
      "dotnet tool restore &&
       dotnet restore ProductService.API/ProductService.API.csproj &&
       dotnet ef database update --project ProductService.Infrastructure/ProductService.Infrastructure.csproj --startup-project ProductService.API/ProductService.API.csproj --no-build"
    environment:
      - ConnectionStrings__DefaultConnection=Server=sqlserver,1433;Database=ProductDbTraining;User Id=sa;Password=Your_password123;TrustServerCertificate=True;

volumes:
  mssqldata:
```

Explanation:

* SQL Server container with persistent storage
* API waits for SQL Server healthcheck before starting
* Migrate container runs EF Core migrations one-time

---

## 4. Commands

### 4.1 Build and start all services

```bash
docker compose up -d --build
```

Example output:

```
Building productsapi ...
Starting sqlserver ... done
Starting productsapi ... done
```

---

### 4.2 Run EF Core migrations manually

```bash
docker compose run --rm migrate
```

Expected output:

```
Build succeeded.
Applying migration 'InitialCreate'
Done.
```

---

### 4.3 Stop and remove all containers and volumes

```bash
docker compose down -v
```

`-v` removes volumes (database reset).

---

## 5. Notes

* `ConnectionStrings__DefaultConnection` overrides `appsettings.json`
* Replace `SA_PASSWORD` for production (use secrets)
* Run migrations from CI/CD pipeline for production systems
* API exposed on port **5000**
* SQL Server exposed on port **1433**

---

## 6. Summary

* `Dockerfile` → multi-stage .NET 8 build
* `docker-compose.yml` → SQL Server, API, migrations
* Commands → build, run migrations, clean
* Database and API fully containerized and ready for duplication across microservices

---
### All containers, ports, and data flow
![alt text](image.png)








