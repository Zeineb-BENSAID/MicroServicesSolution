
# Securing a .NET 8 API with JWT ‚Äî Principles

‚Äî Implement OAuth2 in a .NET 8 API from Scratch

**Goal:** Secure your API using OAuth2 tokens, roles, and policies.

**We will use:**

* .NET 8 API
* Keycloak as the Authorization Server (you can later swap for Auth0, Azure AD, etc.)

---

# 1. What is OAuth2?

**OAuth2** is a protocol to allow secure access to APIs without sharing passwords.
**Key ideas:**

* **Resource Server:** Your API, which validates tokens
* **Authorization Server:** Issues access tokens after user login
* **Client:** Frontend or other apps requesting tokens

**Flow:**

1. User logs in via Authorization Server
2. Authorization Server issues a token
3. API validates token and enforces roles/policies


# Full Tutorial: OAuth2/JWT in .NET 8 API

**Existing solution structure:**

```
MicroServicesSolution/
‚îú‚îÄ‚îÄ ProductService.API/
‚îÇ   ‚îú‚îÄ‚îÄ ProductService.API.csproj
‚îÇ   ‚îú‚îÄ‚îÄ Program.cs
‚îÇ   ‚îú‚îÄ‚îÄ appsettings.json
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ ProductService.Infrastructure/
‚îú‚îÄ‚îÄ ProductService.Application/
‚îú‚îÄ‚îÄ ProductService.Domain/
‚îú‚îÄ‚îÄ docker-compose.yml
‚îî‚îÄ‚îÄ README.md
```

---

## 0Ô∏è‚É£ Step 0 ‚Äî Prerequisites

* **.NET 8 SDK** installed
* **Terminal / PowerShell**
* **Keycloak** downloaded manually from [Keycloak Downloads](https://www.keycloak.org/downloads)

> Keycloak is an **OAuth2 / OpenID Connect server**. Our API will trust it to authenticate users and issue JWT tokens.

---

## 1Ô∏è‚É£ Step 1 ‚Äî What is OAuth2 / JWT?

**OAuth2:** Protocol for **authorizing clients** to access resources.

* **Roles:** Define what a user can do
* **Policies:** Reusable rules combining roles/claims

**JWT (JSON Web Token):** A token that contains **claims** about the user (like `sub`, `role`) and is **signed** by Keycloak.

**Flow:**

```pgsql
User ‚Üí Keycloak ‚Üí JWT Token ‚Üí API ‚Üí Role/Policy check ‚Üí Access granted/denied
```

---


```pgsql
+----------------+           +----------------+           +-----------------+
|                |           |                |           |                 |
|   User /       |           |   Keycloak     |           |   ProductService |
|   Postman /    |           |   OAuth2 Server|           |   API (JWT Secured)|
|   Frontend     |           |                |           |                 |
+----------------+           +----------------+           +-----------------+
        |                           |                           |
        | 1. Requests token         |                           |
        |-------------------------->|                           |
        |                            |                           |
        |                            | 2. Authenticates user      |
        |                            |-------------------------->|
        |                            |                           |
        |                            | 3. Issues JWT token        |
        |<--------------------------|                           |
        |                            |                           |
        | 4. Sends JWT in request    |                           |
        |    to API                  |                           |
        |-------------------------->|                           |
        |                            |                           |
        |                            | 5. API validates token     |
        |                            |   (signature, expiry, roles)|
        |                            |                           |
        |                            | 6. Checks policies / roles |
        |                            |                           |
        |<--------------------------|                           |
        | 7. API returns response    |                           |

```
--------------

## 2Ô∏è‚É£ Step 2 ‚Äî Install and Start Keycloak

**Why:** Keycloak is our OAuth2 server issuing JWT tokens.

**Steps:**

1. Extract Keycloak ZIP (e.g., `keycloak-24.0.0.zip`)
2. Open terminal:

**Windows:**

```powershell
cd keycloak-24.0.0
bin\kc.bat start-dev --http-port=8080
```

**Linux/macOS:**

```bash
cd keycloak-24.0.0
bin/kc.sh start-dev --http-port=8080
```

* Access Keycloak at: `http://localhost:8080`
* Create **admin user** when prompted

> Keycloak runs locally and ready to manage realms, users, roles, and clients.

---

## 3Ô∏è‚É£ Step 3 ‚Äî Create a Realm

**Why:** Realm = workspace for users, clients, and roles. Each API can have its own realm.

**Steps:**

1. Open Keycloak Admin Console
2. Click **top-left dropdown ‚Üí Add Realm**
3. Name it `MyRealm` ‚Üí **Create**

> Now we have a workspace isolated for our ProductService API.

---

## 4Ô∏è‚É£ Step 4 ‚Äî Create API Client

**Why:** API needs a client in Keycloak to validate tokens.

**Steps:**

1. `Realm ‚Üí Clients ‚Üí Create Client`
2. Client ID: `products-api`
3. Protocol: `openid-connect`
4. Access Type: `Bearer-only` ‚Üí **Save**

> Bearer-only: API does **not log in users**, only validates JWTs.

---

## 5Ô∏è‚É£ Step 5 ‚Äî Create Frontend Client

**Why:** Client that requests tokens from Keycloak (like Postman or frontend).

**Steps:**

1. `Realm ‚Üí Clients ‚Üí Create Client`
2. Client ID: `frontend`
3. Protocol: `openid-connect`
4. Access Type: `Public`
5. Valid Redirect URIs: `http://localhost:3000/*` ‚Üí **Save**

> Frontend or Postman will use this to obtain tokens for your API.


# How to set Access Type for a client in Keycloak 26.x

## 1Ô∏è‚É£ Go to your Realm
Login to Keycloak Admin Console ‚Üí select your Realm (e.g., `ProductsRealm`)

---

## 2Ô∏è‚É£ Create a Client
- Left menu ‚Üí **Clients** ‚Üí **Create Client**
- Fill in:

| Field      | Value                     |
|------------|---------------------------|
| Client ID  | `products-api` (or `frontend`) |
| Protocol   | `openid-connect`          |

Click **Save**

---

## 3Ô∏è‚É£ Access Type / Settings
In Keycloak 26.x, the old ‚ÄúAccess Type‚Äù dropdown has been **replaced** by three toggle options under the **Settings** tab:

- **Standard Flow Enabled** ‚Üí corresponds to ‚ÄúConfidential‚Äù (for clients that can do login with credentials)  
- **Direct Access Grants Enabled** ‚Üí allows Resource Owner Password Credentials (optional)  
- **Service Accounts Enabled** ‚Üí corresponds to ‚ÄúBearer-only‚Äù for APIs

---

## 4Ô∏è‚É£ For API (Bearer-only)
In the `products-api` client **Settings** tab:

- **Service Accounts Enabled:** ON  
- **Standard Flow Enabled:** OFF  
- **Direct Access Grants Enabled:** OFF  

> This makes the API a **bearer-only client** (it won‚Äôt login users, only validates tokens).

---

## 5Ô∏è‚É£ For Frontend Client (Public)
In the `frontend` client **Settings** tab:

- **Standard Flow Enabled:** ON  
- **Direct Access Grants Enabled:** OK (unless needed)  
- **Service Accounts Enabled:** OFF  
- **Valid Redirect URIs:** `http://localhost:3000/*`  

> This is the client that requests tokens from Keycloak (like a frontend or Postman).

---

## 6Ô∏è‚É£ Step 6 ‚Äî Create Users

**Why:** Users authenticate via Keycloak to get JWT tokens.

**Steps:**

1. `Realm ‚Üí Users ‚Üí Add User`

   * Username: `john`
   * Email: `john@example.com` ‚Üí Save
2. `Credentials ‚Üí Set Password`

   * Password: `123456`
   * Temporary: OFF ‚Üí Set Password

> User `john` is ready to log in and request tokens.

---

## 7Ô∏è‚É£ Step 7 ‚Äî Create Roles

**Why:** Roles control **which endpoints a user can access**.

**Steps:**

1. `Realm ‚Üí Roles ‚Üí Add Role`

   * Roles: `Admin`, `User`, `ProductsEditor`
2. Assign roles to user `john`:

```
Users ‚Üí john ‚Üí Role Mappings ‚Üí Assign Role
```

> Roles are used in your API for **policy-based or role-based authorization**.

---

## 8Ô∏è‚É£ Step 8 ‚Äî Obtain Access Token (Test)

**Why:** To test your API before coding.

```bash
curl -X POST "http://localhost:8080/realms/MyRealm/protocol/openid-connect/token" \
-d "client_id=frontend" \
-d "grant_type=password" \
-d "username=john" \
-d "password=123456"
```

* **Response:**

```json
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR...",
  "refresh_token": "...",
  "expires_in": 300
}
```

> Copy `access_token` ‚Äî this JWT will be used to authenticate API requests.

---

## 9Ô∏è‚É£ Step 9 ‚Äî Install JWT and Swagger Packages in API

**Why:** JWT package to validate tokens, Swagger to test endpoints.

```bash
cd MicroServicesSolution/ProductService.API
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
dotnet add package Swashbuckle.AspNetCore
```

---

## üîü Step 10 ‚Äî Update `appsettings.json`

```json
{
  "Auth": {
    "Authority": "http://localhost:8080/realms/MyRealm",
    "Audience": "products-api"
  }
}
```

> Authority = Keycloak server URL
> Audience = API client ID

---

## 1Ô∏è‚É£1Ô∏è‚É£ Step 11 ‚Äî Configure `Program.cs`

```csharp
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using Microsoft.OpenApi.Models;

var builder = WebApplication.CreateBuilder(args);

// JWT Authentication
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.Authority = builder.Configuration["Auth:Authority"];
        options.Audience = builder.Configuration["Auth:Audience"];
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true
        };
    });

// Authorization Policies
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("AdminOnly", policy => policy.RequireRole("Admin"));
    options.AddPolicy("CanEditProducts", policy => policy.RequireRole("ProductsEditor"));
});

// Swagger with JWT support
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "ProductService API", Version = "v1" });

    var securityScheme = new OpenApiSecurityScheme
    {
        Name = "Authorization",
        Type = SecuritySchemeType.Http,
        Scheme = "bearer",
        BearerFormat = "JWT",
        In = ParameterLocation.Header,
        Description = "Enter 'Bearer' followed by your token"
    };
    c.AddSecurityDefinition("Bearer", securityScheme);

    var securityRequirement = new OpenApiSecurityRequirement
    {
        { securityScheme, new string[] {} }
    };
    c.AddSecurityRequirement(securityRequirement);
});

builder.Services.AddControllers();

var app = builder.Build();

app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();

app.UseSwagger();
app.UseSwaggerUI(c =>
{
    c.SwaggerEndpoint("/swagger/v1/swagger.json", "ProductService API V1");
});

app.MapControllers();
app.Run();
```

> **Explanation:**
>
> * `AddAuthentication` validates JWTs from Keycloak
> * `AddAuthorization` enforces role-based policies
> * Swagger configured to accept JWT tokens

---

## 1Ô∏è‚É£2Ô∏è‚É£ Step 12 ‚Äî Secure API Endpoints

```csharp
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    [HttpGet]
    [Authorize] // any authenticated user
    public IActionResult GetAll() => Ok("All products");

    [HttpPost]
    [Authorize(Policy = "CanEditProducts")] // ProductsEditor role
    public IActionResult Create() => Ok("Created");

    [HttpDelete("{id}")]
    [Authorize(Roles = "Admin")] // Admin only
    public IActionResult Delete(Guid id) => Ok($"Deleted {id}");
}
```

---

## 1Ô∏è‚É£3Ô∏è‚É£ Step 13 ‚Äî Run API & Test with Swagger

```bash
dotnet run
```

1. Open browser: `https://localhost:5001/swagger`
2. Click **Authorize** ‚Üí paste JWT: `Bearer <ACCESS_TOKEN>`
3. Test endpoints:

   * GET `/api/products` ‚Üí should work for any authenticated user
   * POST `/api/products` ‚Üí only `ProductsEditor`
   * DELETE `/api/products/{id}` ‚Üí only `Admin`

> Swagger simulates a real client with JWT token.

---

## ‚úÖ Step 14 ‚Äî Summary

* **OAuth2:** Protocol to request JWT tokens
* **JWT:** Signed token containing user claims & roles
* **Realm:** Isolated workspace in Keycloak
* **Client:** Application registered in Keycloak (API or frontend)
* **User & Roles:** Control access to endpoints
* **API:** Validates JWT and enforces roles/policies
* **Swagger:** Easy testing with `Authorize` button



********************************************************************************


---

# üöÄ Fixing Keycloak Error: `JAVA_HOME is not set` / `"java" is not recognized`

When you run:

```
bin\kc.bat start-dev --http-port=8080
```

Keycloak shows:

```
JAVA_HOME is not set. Unexpected results may occur.
"java" is not recognized as an internal or external command
```

This means **Java is not installed or not configured correctly on Windows**.

---

## ‚úÖ 1. Check if Java is installed

Open a terminal and run:

```cmd
java -version
```

If you get an error ‚Üí **Java is not installed**.

---

## ‚úÖ 2. Install JDK 21 (required for Keycloak 26.x)

Download Temurin JDK 21 (LTS):
üëâ [https://adoptium.net/temurin/releases/?version=21](https://adoptium.net/temurin/releases/?version=21)

Choose **Windows x64 ‚Äî MSI Installer**.

---

## ‚úÖ 3. Set up JAVA_HOME on Windows

1. Open:
   **Control Panel ‚Üí System ‚Üí Advanced system settings ‚Üí Environment Variables**

2. In **System variables**, click **New**:

   * **Name**: `JAVA_HOME`
   * **Value** (example):

     ```
     C:\Program Files\Eclipse Adoptium\jdk-21
     ```

3. Update the **Path** variable:

   * Click **Edit**
   * Add a new entry:

     ```
     %JAVA_HOME%\bin
     ```

---

## ‚úÖ 4. Verify the configuration

Open a new CMD or PowerShell:

```cmd
java -version
```

You should see something like:

```
openjdk version "21..."
```

---

## ‚úÖ 5. Start Keycloak again

From your Keycloak directory:

```cmd
bin\kc.bat start-dev --http-port=8080
```

If Java is correctly installed, Keycloak will start normally.

---





