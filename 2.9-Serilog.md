# **.NET 8 Microservices Logging Guide (Serilog + JSON + stdout/stderr)**

How to configure logging in a .NET 8 microservices backend application using:

* **Serilog**
* **Structured JSON logs**
* **stdout for INFO logs**
* **stderr for ERROR logs**

This setup follows **cloud-native best practices** and is optimized for Docker, Kubernetes, and log centralization systems like ELK, Loki, Seq, and Application Insights.

---

## **1. Install Serilog Packages**

Run the following commands in your microservice project:

```bash
dotnet add package Serilog.AspNetCore
dotnet add package Serilog.Settings.Configuration
dotnet add package Serilog.Sinks.Console
```

**Explanation:**
Serilog replaces the default .NET logger and allows structured JSON logging.

---

##  **2. Configure Serilog in `appsettings.json`**

Add the following configuration to separate logs:

* INFO → **stdout**
* ERROR → **stderr**

```json
{
  "Serilog": {
    "Using": [ "Serilog.Sinks.Console" ],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "formatter": "Serilog.Formatting.Json.JsonFormatter, Serilog"
        }
      },
      {
        "Name": "Console",
        "Args": {
          "formatter": "Serilog.Formatting.Json.JsonFormatter, Serilog",
          "restrictedToMinimumLevel": "Error",
          "standardErrorFromLevel": "Error"
        }
      }
    ],
    "Enrich": [ "FromLogContext", "WithMachineName" ]
  }
}
```

**Explanation:**

* The first sink prints all logs ≥ Information to **stdout**.
* The second sink prints logs ≥ Error to **stderr**.
* This ensures clean separation for Docker/Kubernetes log pipelines.

---

##  **3. Enable Serilog in `Program.cs`**

```csharp
using Serilog;

var builder = WebApplication.CreateBuilder(args);

Log.Logger = new LoggerConfiguration()
    .ReadFrom.Configuration(builder.Configuration)
    .CreateLogger();

builder.Host.UseSerilog();

var app = builder.Build();
app.MapGet("/", () => "OK");
app.Run();
```

**Explanation:**
This replaces the default .NET logger with Serilog using your JSON configuration.

---

##  **4. Write Logs in Your Code**

```csharp
_logger.LogInformation("Product created successfully");
_logger.LogError("Failed to create product");
```

**Explanation:**
You still use the built-in `ILogger<T>` interface. Serilog handles the output formatting.

---

##  **5. Where Are Logs Stored?**

### ❌ Not in files

Your app does **not** generate `.log` files.

### INFO logs

Sent to **stdout** (standard output)

### ERROR logs

Sent to **stderr** (standard error)

This is the recommended cloud-native behavior.

---

##  **6. How to Read the Logs**

### ### **A. Local Development**

Run:

```bash
dotnet run
```

You will see both stdout + stderr logs in your terminal.

---

### **B. Docker**

Read all logs:

```bash
docker logs <container>
```

Read only INFO logs (stdout):

```bash
docker logs --stdout <container>
```

Read only ERROR logs (stderr):

```bash
docker logs --stderr <container>
```

Follow logs live:

```bash
docker logs -f <container>
```

---

###  **C. Kubernetes**

Get logs from a pod:

```bash
kubectl logs <pod-name>
```

Only INFO logs:

```bash
kubectl logs <pod-name> --output=stdout
```

Only ERROR logs:

```bash
kubectl logs <pod-name> --output=stderr
```

---

###  **D. Log Platforms (ELK, Loki, Seq)**

These tools collect logs automatically from stdout/stderr.

Examples:

| Platform | How logs appear                             |
| -------- | ------------------------------------------- |
| **ELK**  | INFO in `info-*` index, ERROR in `error-*`  |
| **Loki** | `{stream="stdout"}` and `{stream="stderr"}` |
| **Seq**  | Filter by `@Level == 'Error'`               |

---

##  **7. Why Not Use Log Files in Microservices?**

### Storing logs in files is **not recommended** because:

* Containers are **ephemeral**
* Files disappear when a container restarts
* Hard to aggregate logs from multiple replicas
* stdout/stderr is automatically collected by Docker/K8s
* Log collectors expect JSON logs on stdout

**Conclusion:**
stdout/stderr logging is the modern, recommended, cloud-native method.

---

##  **Done!**

* Production-ready logging setup
* JSON structured logs
* Clean separation between INFO and ERROR logs
* Docker/Kubernetes-friendly pipeline


